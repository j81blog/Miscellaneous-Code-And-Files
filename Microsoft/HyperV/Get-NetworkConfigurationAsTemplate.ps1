<#
.SYNOPSIS
    Analyzes the network configuration of a server and generates PowerShell
    commands to replicate that configuration.

.DESCRIPTION
    This script inspects NIC Teams (LBFO and SET), Hyper-V virtual switches,
    VLAN settings, and RDMA/QoS configurations. It then outputs a series of
    PowerShell commands that can be used as a template to configure new servers
    with the same settings.

.PARAMETER OutputFile
    The file path where the generated template will be saved. Defaults to "NetworkConfigurationTemplate.ps1".

.PARAMETER SaveToFile
    If specified, the output will be saved to the file defined in OutputFile.

.EXAMPLE
    PS C:\> Get-NetworkConfigurationAsTemplate -OutputFile C:\Temp\NetworkConfigTemplate.ps1 -SaveToFile
    Generates a network configuration template and saves it to C:\Temp\NetworkConfigTemplate.ps1.

.EXAMPLE
    PS C:\> Get-NetworkConfigurationAsTemplate
    Outputs the network configuration template to the console without saving to a file.

.NOTES
    Version       : 1.2
    Author        : John Billekens Consultancy
    Co-Author     : Gemini (Documentation and review)
    CreationDate  : 2025-08-18
    Compatibility : Works with Windows Server 2012 through 2025.
#>
function Get-NetworkConfigurationAsTemplate {
    [CmdletBinding()]
    [OutputType([string])]
    param (
        [Parameter(Mandatory = $false)]
        [string]$OutputFile = "NetworkConfigurationTemplate.ps1",

        [Parameter(Mandatory = $false)]
        [Switch]$SaveToFile

    )
    Write-Host "--- Generating Network Configuration Template ---" -ForegroundColor Green

    #region NIC Teaming (LBFO & SET) / Virtual Switches
    Write-Host "`n## 1. NIC Teams and Virtual Switches" -ForegroundColor Yellow
    #Create stringmap
    $OutputFileData = New-Object System.Text.StringBuilder
    $ComputerInfo = Get-ComputerInfo
    $OutputFileData.AppendLine("[CmdletBinding()]") | Out-Null
    $OutputFileData.AppendLine("param ()") | Out-Null
    $OutputFileData.AppendLine("`n# This script was generated by Get-NetworkConfigurationAsTemplate.ps1") | Out-Null
    $OutputFileData.AppendLine("# Generated on: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')") | Out-Null
    $OutputFileData.AppendLine("# Generated by: $($env:USERNAME)") | Out-Null
    $OutputFileData.AppendLine("# Generated from: $($ComputerInfo.CsName)") | Out-Null
    $OutputFileData.AppendLine("# Generated on OS: $($ComputerInfo.WindowsVersion)") | Out-Null
    $OutputFileData.AppendLine("# Generated on PowerShell Version: $($PSVersionTable.PSVersion)") | Out-Null
    try {
        $VmSwitches = Get-VMSwitch -ErrorAction Stop

        foreach ($Switch in $VmSwitches) {
            Write-Host "`n# Configuration for vSwitch: $($Switch.Name)" -ForegroundColor Cyan
            $OutputFileData.AppendLine("`n# Configuration for vSwitch: $($Switch.Name)") | Out-Null

            if ($Switch.EnableEmbeddedTeaming) {
                $AdapterNames = ($Switch.NetAdapterInterfaceDescription | ForEach-Object { "'$_'" }) -join ", "
                Write-Host "New-VMSwitch -Name '$($Switch.Name)' -NetAdapterName $AdapterNames -EnableEmbeddedTeaming `$true -AllowManagementOS $($Switch.AllowManagementOS)"
                $OutputFileData.AppendLine("New-VMSwitch -Name '$($Switch.Name)' -NetAdapterName $AdapterNames -EnableEmbeddedTeaming `$true -AllowManagementOS $($Switch.AllowManagementOS)") | Out-Null
            } else {
                $SwitchType = $Switch.SwitchType
                $Command = "New-VMSwitch -Name '$($Switch.Name)' -SwitchType $SwitchType"
                if ($SwitchType -eq 'External' -and $Switch.NetAdapterInterfaceDescription) {
                    $AdapterName = $Switch.NetAdapterInterfaceDescription
                    $Command += " -NetAdapterName '$AdapterName'"
                }
                $Command += " -AllowManagementOS $($Switch.AllowManagementOS)"
                Write-Host $Command
                $OutputFileData.AppendLine($Command) | Out-Null
            }

            $ManagementAdapter = Get-VMNetworkAdapter -ManagementOS | Where-Object { $_.SwitchName -eq $Switch.Name }
            if ($ManagementAdapter) {
                $VlanId = (Get-VMNetworkAdapterVlan -VMNetworkAdapter $ManagementAdapter).AccessVlanId
                Write-Host "Add-VMNetworkAdapter -ManagementOS -Name '$($ManagementAdapter.Name)' -SwitchName '$($Switch.Name)'"
                $OutputFileData.AppendLine("Add-VMNetworkAdapter -ManagementOS -Name '$($ManagementAdapter.Name)' -SwitchName '$($Switch.Name)'" ) | Out-Null
                if ($VlanId -gt 0) {
                    Write-Host "Set-VMNetworkAdapterVlan -ManagementOS -VMNetworkAdapterName '$($ManagementAdapter.Name)' -Access -VlanId $VlanId"
                    $OutputFileData.AppendLine("Set-VMNetworkAdapterVlan -ManagementOS -VMNetworkAdapterName '$($ManagementAdapter.Name)' -Access -VlanId $VlanId") | Out-Null
                }
            }
        }
    } catch {
        Write-Warning "Could not retrieve Hyper-V virtual switches. Is the Hyper-V role installed?"
    }

    try {
        $LBFOTeams = Get-NetLbfoTeam -ErrorAction Stop
        foreach ($Team in $LBFOTeams) {
            Write-Host "`n# Configuration for LBFO Team: $($Team.Name)" -ForegroundColor Cyan
            $OutputFileData.AppendLine("`n# Configuration for LBFO Team: $($Team.Name)") | Out-Null
            $TeamMembers = ($Team.Members | ForEach-Object { "'$_'" }) -join ", "
            Write-Host "New-NetLbfoTeam -Name '$($Team.Name)' -TeamMembers $TeamMembers -TeamingMode $($Team.TeamingMode) -LoadBalancingAlgorithm $($Team.LoadBalancingAlgorithm)"
            $OutputFileData.AppendLine("New-NetLbfoTeam -Name '$($Team.Name)' -TeamMembers $TeamMembers -TeamingMode $($Team.TeamingMode) -LoadBalancingAlgorithm $($Team.LoadBalancingAlgorithm)") | Out-Null
        }
    } catch {}
    #endregion

    #region VLAN Configuration on Physical Adapters
    Write-Host "`n## 2. VLAN Configuration (Physical/Team Interfaces)" -ForegroundColor Yellow
    $OutputFileData.AppendLine("`n## 2. VLAN Configuration (Physical/Team Interfaces)") | Out-Null

    # MODIFICATION for Server 2025 Compatibility:
    # The Get-NetAdapterVlan cmdlet is removed. VLAN info is now a direct property of the adapter object.
    $VlanAdapters = Get-NetAdapter | Where-Object { $_.VlanID -gt 0 }
    foreach ($Adapter in $VlanAdapters) {
        Write-Host "`n# Configuration for VLAN on adapter: $($Adapter.Name)" -ForegroundColor Cyan
        $OutputFileData.AppendLine("`n# Configuration for VLAN on adapter: $($Adapter.Name)") | Out-Null
        Write-Host "Set-NetAdapter -Name '$($Adapter.Name)' -VlanID $($Adapter.VlanID)"
        $OutputFileData.AppendLine("Set-NetAdapter -Name '$($Adapter.Name)' -VlanID $($Adapter.VlanID)") | Out-Null
    }
    #endregion

    #region RDMA and QoS/DCB Configuration
    Write-Host "`n## 3. RDMA and QoS (DCB) Configuration" -ForegroundColor Yellow
    $OutputFileData.AppendLine("`n## 3. RDMA and QoS (DCB) Configuration") | Out-Null

    try {
        if (-not (Get-WindowsFeature -Name Data-Center-Bridging).Installed) {
            Write-Host "`n# Data-Center-Bridging feature is not installed. To install:" -ForegroundColor Cyan
            $OutputFileData.AppendLine("`n# Data-Center-Bridging feature is not installed. To install:") | Out-Null
            Write-Host "Install-WindowsFeature -Name Data-Center-Bridging -IncludeManagementTools"
            $OutputFileData.AppendLine("Install-WindowsFeature -Name Data-Center-Bridging -IncludeManagementTools") | Out-Null
        } else {
            $RdmaAdapters = Get-NetAdapterRdma -ErrorAction Stop | Where-Object { $_.Enabled }
            if ($RdmaAdapters) {
                Write-Host "`n# Enable RDMA on the following adapters:" -ForegroundColor Cyan
                $OutputFileData.AppendLine("`n# Enable RDMA on the following adapters:") | Out-Null
                foreach ($Adapter in $RdmaAdapters) {
                    Write-Host "Enable-NetAdapterRdma -Name '$($Adapter.Name)'"
                    $OutputFileData.AppendLine("Enable-NetAdapterRdma -Name '$($Adapter.Name)'" ) | Out-Null
                }
            }

            $QosAdapters = Get-NetAdapterQos -ErrorAction Stop | Where-Object { $_.Enabled }
            if ($QosAdapters) {
                Write-Host "`n# Enable QoS (DCB) on the following adapters:" -ForegroundColor Cyan
                $OutputFileData.AppendLine("`n# Enable QoS (DCB) on the following adapters:") | Out-Null
                foreach ($Adapter in $QosAdapters) {
                    Write-Host "Set-NetAdapterQos -Name '$($Adapter.Name)' -Enabled `$true"
                    $OutputFileData.AppendLine("Set-NetAdapterQos -Name '$($Adapter.Name)' -Enabled `$true") | Out-Null
                }
            }

            $TrafficClasses = Get-NetQosTrafficClass -ErrorAction Stop | Where-Object { $_.Name -ne '[Default]' }
            if ($TrafficClasses) {
                Write-Host "`n# Create custom QoS Traffic Classes:" -ForegroundColor Cyan
                $OutputFileData.AppendLine("`n# Create custom QoS Traffic Classes:") | Out-Null
                foreach ($Class in $TrafficClasses) {
                    Write-Host "New-NetQosTrafficClass -Name '$($Class.Name)' -Priority $($Class.Priority.replace(' ',', ' )) -Algorithm $($Class.Algorithm) -BandwidthPercentage $($Class.BandwidthPercentage)"
                    $OutputFileData.AppendLine("New-NetQosTrafficClass -Name '$($Class.Name)' -Priority $($Class.Priority.replace(' ',', ' )) -Algorithm $($Class.Algorithm) -BandwidthPercentage $($Class.BandwidthPercentage)") | Out-Null
                }
            }

            $QosPolicies = Get-NetQosPolicy -ErrorAction Stop | Where-Object { $_.Name -notlike 'Default*' }
            if ($QosPolicies) {
                Write-Host "`n# Create custom QoS Policies:" -ForegroundColor Cyan
                $OutputFileData.AppendLine("`n# Create custom QoS Policies:") | Out-Null
                foreach ($Policy in $QosPolicies) {
                    $PolicyCommand = "New-NetQosPolicy -Name '$($Policy.Name)' -Priority $($Policy.Priority)"
                    if ($Policy.SMB) { $PolicyCommand += " -SMB" }
                    if ($Policy.NetDirectPort) { $PolicyCommand += " -NetDirectPort $($Policy.NetDirectPort)" }
                    Write-Host $PolicyCommand
                    $OutputFileData.AppendLine($PolicyCommand) | Out-Null
                }
            }
        }
    } catch {
        Write-Warning "Could not retrieve RDMA/QoS settings. Is the Data-Center-Bridging feature installed?"
    }
    if ($OutputFileData) {
        $OutputFileData.ToString() | Out-File -FilePath $OutputFile -Encoding UTF8
    }
    #endregion

    Write-Host "`n--- Template Generation Complete ---" -ForegroundColor Green
}
